package handlers

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"

	"github.com/bradpurchase/grocerytime-backend/internal/pkg/gql"
	"github.com/gorilla/websocket"
	"github.com/graphql-go/graphql"
	subscription "github.com/trevex/graphql-go-subscription"
	"github.com/trevex/graphql-go-subscription/examples/pubsub"
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
}

// GraphQLMessage defines the query, operation name and variables of a graphql request
type GraphQLMessage struct {
	Query         string                 `json:"query"`
	OperationName string                 `json:"operationName"`
	Variables     map[string]interface{} `json:"variables"`
}

// Message defines the graphql messages sent between client and server
//TODO this should be an enum based on the types in the graphql-ws protocol
type Message struct {
	Type    string         `json:"type"`
	ID      string         `json:"id"`
	Payload GraphQLMessage `json:"payload"`
}

// WebsocketMessage is the message payload sent between
// graphql subscription client and server
type WebsocketMessage struct {
	Type    string          `json:"type"`
	ID      string          `json:"id"`
	Payload *graphql.Result `json:"payload"`
}

// SubscriptionIDMap provides a mapping of the id used for graphql subscriptions
// to the internal subscription ID
type SubscriptionIDMap struct {
	GraphqlRequestID string // each subscription on a socket has a new gql request ID
	SubscriptionID   subscription.SubscriptionId
}

var (
	// Clients is a map of connections to structs that map graphql request IDs
	// to subscriptions
	Clients             map[*websocket.Conn]SubscriptionIDMap
	gqlPubSub           *pubsub.PubSub
	subscriptionManager *subscription.SubscriptionManager
)

func init() {
	Clients = make(map[*websocket.Conn]SubscriptionIDMap)
	gqlPubSub = pubsub.New(4)
	subscriptionManager = subscription.NewSubscriptionManager(subscription.SubscriptionManagerConfig{
		Schema: gql.Schema,
		PubSub: gqlPubSub,
	})
}

// WebsocketHandler handles websocket requests
func WebsocketHandler() http.HandlerFunc {
	return func(response http.ResponseWriter, request *http.Request) {
		log.Println("[WebsocketHandler] handling websocket...")

		var mutex = &sync.Mutex{}
		responseHeaders := http.Header{"Sec-WebSocket-Protocol": {"graphql-ws"}}
		conn, err := upgrader.Upgrade(response, request, responseHeaders)
		if err != nil {
			log.Println(err)
			return
		}

		for {
			mt, message, err := conn.ReadMessage()
			if err != nil {
				log.Println("read:", err)
				break
			}
			fmt.Printf("RECV message: %s with type ID %d\n", message, mt)

			var payloadResponse []byte

			// Convert the message to a struct
			var websocketMessage Message
			_ = json.Unmarshal(message, &websocketMessage)
			fmt.Printf("received message from: %s / type %s / payload %s / type ID %d\n", conn.RemoteAddr(), websocketMessage.Type, websocketMessage.Payload, mt)

			var subID subscription.SubscriptionId
			if websocketMessage.Type == "connection_init" {
				log.Println("received connection init - generating an ack")
				response := Message{
					Type: "connection_ack",
				}
				payloadResponse, _ = json.Marshal(response)
				if payloadResponse != nil {
					fmt.Printf("writing %s\n", payloadResponse)
					mutex.Lock()
					err = conn.WriteMessage(mt, payloadResponse)
					mutex.Unlock()
					if err != nil {
						log.Println("write:", err)
						break
					}
				}
			} else if websocketMessage.Type == "start" {
				fmt.Printf("received start - generating a subscription manager for id %s with payload %s\n", websocketMessage.ID, websocketMessage.Payload)

				subID, err = subscriptionManager.Subscribe(subscription.SubscriptionConfig{
					Query:          websocketMessage.Payload.Query,
					VariableValues: websocketMessage.Payload.Variables,
					OperationName:  websocketMessage.Payload.OperationName,
					Callback: func(result *graphql.Result) error {
						fmt.Printf("processing callback with result: %v\n", result)

						if result.Errors != nil {
							log.Println("error trying to find message: ", result.Errors)
							return nil
						}

						payload, _ := json.Marshal(result)
						fmt.Printf("writing payload %s back to websocket %s\n", payload, conn.RemoteAddr().String())

						websocketResponseMessage := WebsocketMessage{
							Type:    "data",
							ID:      websocketMessage.ID,
							Payload: result,
						}

						mutex.Lock()
						conn.WriteJSON(websocketResponseMessage)
						mutex.Unlock()
						return nil
					},
				})

				// At this point, we need to define a mapping from the subscription ID
				// (which is provided in the request) to the subID generated by the SubscriptionManager
				if err != nil {
					fmt.Printf("error creating subscription %s\n", err)
				}

				fmt.Printf("\t\t\t\tcreating subscription for %d\n", subID)

				//NOTE: this isn't threadsafe, and assumes 1 subscription per websocket
				idMap := SubscriptionIDMap{
					GraphqlRequestID: websocketMessage.ID,
					SubscriptionID:   subID,
				}
				Clients[conn] = idMap
			} else if websocketMessage.Type == "stop" {
				idMap := Clients[conn]
				fmt.Printf("STOP unsubscribe number %d...\n", idMap.SubscriptionID)
				subscriptionManager.Unsubscribe(idMap.SubscriptionID)
			} else {
				fmt.Printf("received unknown message type %s with payload %s\n", websocketMessage.Type, websocketMessage.Payload)
			}
		}

		log.Println("goodbye socket...")
		idMap := Clients[conn]
		subscriptionManager.Unsubscribe(idMap.SubscriptionID)
		conn.Close()
	}
}
